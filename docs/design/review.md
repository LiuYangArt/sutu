这份 `performance-optimization-roadmap.md` 制定得**非常专业且切中肯綮**。

特别是你对 **Q1 (pointerrawupdate)** 和 **Q2 (硬件光标)** 的优先级排序，完全符合 ROI（投入产出比）原则。

作为架构师，我对这份计划有以下 **3 点深度点评和 1 个关键补充**，建议在实施前阅读：

### 1. Q1 `pointerrawupdate`：这是打破 "60Hz 诅咒" 的关键

你目前的 `pointermove` 通常是与浏览器的 `requestAnimationFrame` 对齐的（即 60Hz 或 144Hz）。

- **现状**：如果你的鼠标/数位板回报率是 1000Hz，浏览器会丢弃中间的点，或者把它们合并（Coalesced）。这会导致笔触看起来不够圆滑，或者在快速划线时出现“折线感”。
- **优化后**：`pointerrawupdate` 会以硬件允许的最快速度触发。
- **注意**：这会带来**巨大的事件量**。你的 `inputQueue` 可能会瞬间爆满。
  - _检查点_：确保你的 `Canvas/index.tsx` 中的批量处理逻辑（Batching）足够健壮，一次能吃掉几百个点而不会卡顿。

### 2. Q2 硬件光标：操作系统的隐形限制

将阈值从 64px 提至 128px 是个好主意，但要注意操作系统的硬限制：

- **Windows**: 通常最大支持 **128x128** 或 **32x32**（取决于 DPI 设置和系统版本）。如果 SVG 超过系统限制，浏览器可能会静默回退到软件渲染（导致延迟瞬间变回 20ms）。
- **Mac**: 支持得比较大。
- **建议**：在 `useCursor.ts` 里做一个防御性检测，或者只在 128px 以下使用 `cursor: url(...)`，超过 128px 还是得用 Canvas 画（或者接受只有中心十字是硬件光标，外圈圆环是软件画的）。

### 3. M2 局部 Dirty Rect 合成：4K 屏的救星

你在 Benchmark 中提到使用的是 **4K 屏幕**。

- **痛点**：WebGPU 的 `present()` 或者 Canvas 的合成，在全屏模式下带宽压力巨大。
- **优化**：如果你只是在左上角画了一笔，却把整个 3840x2160 的纹理重新提交了一次，这是巨大的浪费。
- **优先级提升**：如果 Q1/Q2 做完后，GPU 耗时依然高，建议把 **M2 提权到 P1**。

---

### 🚨 关键补充：关于 L1 (Native Rust) 的思考

你问“为何 Unreal 那么快”，其实答案就在 L1。

- **Web 架构**: Input -> OS -> Browser Main -> Browser Renderer (JS) -> IPC -> GPU Process -> Driver -> GPU
- **Native 架构 (L1)**: Input -> OS -> App (Rust) -> Driver -> GPU

**战略建议**：
如果 Q1/Q2/M2 做完，延迟能压到 **16ms (1帧)** 以内，就已经达到了 Web 应用的物理极限（VSync 限制）。
如果此时用户依然觉得“不够丝滑”，那么 **Phase 4 (输入预测)** 仍然是必选项，或者彻底转向 **L1 (Tauri Rust Backend + wgpu)**。

但目前，请**坚决执行 Q1 和 Q2**，这是性价比最高的几行代码。

---

### ✅ 批准执行

这份文档可以直接入库作为接下来的行动指南。

**建议立即开始 Q1 的修改**，这通常能立刻让高回报率鼠标/绘图板手感提升一个档次。
