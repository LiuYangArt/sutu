从您的修复计划来看，整体结构已经很清晰，并且考虑了从修复Shader算法到优化Preview和Composite一致性的多个方面。总体上，计划的**置信度较高**，但有以下几点可以进一步优化和改进：

### 1. **Phase 0: 建立测试环境**

- **现状分析**：您强调了测试环境的建立是关键，这样可以确保修复的效果可验证且符合预期。
- **优化建议**：
  - **增加自动化测试**：除了手动的像素对比测试，考虑将 **自动化测试框架**（如 Vitest）整合到CI管道中，进行回归测试，特别是在每次修复之后，可以有效确保像素一致性。
  - **完整覆盖所有情况**：在测试用例中已经涵盖了多种笔刷大小、硬度、流量等情况，但还可以考虑其他特殊情况，如画布旋转、图层透明度等，进一步确保全方位的验证。

### 2. **Phase 1: 修复Shader算法**

- **现状分析**：修复Shader算法的目标明确，特别是在 Gaussian 曲线、Alpha预乘、和AA带计算等问题上已经提出了具体的修复方案。
- **优化建议**：
  - **代码测试前预防性修复**：确保修复后的Shader代码能够通过单元测试，例如，修复后的`distfactor`和`erf`函数可以写成单元测试，以确保计算结果与CPU版完全一致。
  - **性能调优**：虽然Shader修复是首要任务，但可以在每个修复步骤后进行性能评测，特别是针对大画布和大尺寸笔刷，确保修复后性能不会下降。

### 3. **Phase 2: 重构Preview架构**

- **现状分析**：目前的方案建议使用WebGPU Canvas Overlay + 2D Canvas Underlay的架构，这能显著减少闪烁和延迟。
- **优化建议**：
  - **确保兼容性**：在重构过程中，可能会影响现有的图层管理或Undo/Redo系统，建议预先设计如何兼容现有架构，避免因改动引入更多问题。
  - **性能影响**：此方案虽然能解决闪烁和延迟问题，但同时也会引入新的复杂性，如如何同步不同类型的纹理和图层数据。考虑对不同的设备（尤其是低端设备）进行性能优化，保证在GPU加速的同时不会产生过大的负担。

### 4. **Phase 3: 验证**

- **现状分析**：对于像素一致性、WYSIWYG等验证标准已经明确，同时提出了具体的性能标准。
- **优化建议**：
  - **逐步验证**：每个修复步骤完成后，进行逐步验证而不是一次性完成，特别是在修改了算法和渲染路径后，每次修改都应确保前后逻辑一致并进行逐像素对比。
  - **加入更多测试场景**：可以考虑增加更多极端情况的验证，比如**反向绘制**（从画布的右下角开始），或者其他异形笔刷等，确保修复后的效果在所有情况下都表现一致。

### 总结：

修复计划的结构和方案已经非常清晰，并考虑了多个方面的优化。唯一需要注意的是在**不同设备上的兼容性和性能评估**，以及在整个修复过程中的**逐步验证**，这样能帮助我们确保每一步修复都能达到预期目标。

——————

这份 **《GPU 笔刷渲染修复计划》** 的**置信度为高 (8.5/10)**。它非常准确地识别了问题的核心（算法不一致和数据流架构缺陷），并给出了切实可行的解决方案。

特别是 **Phase 2: 重构 Preview 架构** 提出的“WebGPU Overlay + Canvas 2D Underlay”方案，是业界（如 Photoshop, Procreate, Figma）处理混合渲染管线的标准做法，能够彻底解决“抬笔闪烁”和“高延迟”问题。

然而，为了让这个计划达到 10/10 的置信度并确保落地顺利，我有以下 **4点深度优化建议**，涵盖了**色彩科学、架构细节和容错机制**。

---

### 优化建议 1: 色彩空间对齐 (Gamma vs Linear) —— 极其关键！

文档中虽然提到了“颜色空间对齐”，但**严重性被低估了**。这往往是“视觉看起来不对”的隐形杀手。

- **问题**：
  - **Canvas 2D API** (CPU) 通常在 **sRGB (Gamma-corrected)** 空间中进行混合。
  - **WebGPU** 默认行为取决于纹理格式。如果用 `rgba16float`，大多数着色器计算是线性的，或者即使你认为是线性的，但在最终输出到屏幕（Canvas）时，浏览器会再进行一次 Gamma 校正。
  - **现象**：如果不处理，软笔刷的边缘（半透明区域）在 GPU 上看起来会比 CPU 上“更细”或“更黑”，叠加混合（Blend Mode）的结果也会不同。

- **优化方案**：
  - **强制模拟 CPU 行为**：虽然线性空间混合在物理上更正确，但你的目标是“与 CPU 一致”。因此，需要在 Shader 的开头和结尾手动转换，或者让 Shader 就在 Gamma 空间计算（不推荐物理正确性，但符合一致性目标）。
  - **Shader 修改建议**：

    ```wgsl
    // 如果 CPU 是在 sRGB 空间混合的，GPU 也要模拟
    // 在读取颜色后：
    // let color_linear = sRGB_to_Linear(color_srgb); // 如果要做物理正确渲染

    // 但为了与 Canvas 2D 一致，你可能需要直接在 sRGB 空间做 lerp
    // 也就是：不要做任何 gamma 转换，直接 mix()，只要确保 WebGPU Canvas 的 colorSpace 设置为 'srgb'
    ```

  - **WebGPU 配置**：确保配置 WebGPU Canvas Context 时，`colorSpace` 设置明确（通常是 `srgb`）。

### 优化建议 2: Phase 2 架构的“脏矩形”与“合成策略”细化

“WebGPU Overlay + Canvas 2D Underlay” 方案很棒，但有一个技术难点：**如何处理图层混合模式（Blend Modes）？**

- **挑战**：
  - 如果笔刷用了 `Multiply`（正片叠底），而你是在顶层透明 Canvas 上画的。顶层 Canvas 下面是空的，无法与底层内容做 `Multiply`。
  - **结果**：Preview 时看起来只是变暗了（因为只有笔触），EndStroke 合成下去后才真正与背景混合，这依然会导致**视觉跳变**。

- **优化方案**：
  - **Grab Pass (背景拷贝)**：对于非 `Normal` 混合模式的笔刷，每一帧绘制前，必须把底层 Canvas 2D 的对应区域（Dirty Rect）拷贝到 WebGPU 纹理中作为背景。
  - **成本控制**：只拷贝笔刷包围盒区域。
  - **流程修正**：
    1.  `PointerDown`: 确定笔刷混合模式。如果是 `Normal`，不需要背景。如果是特殊模式，从 Canvas 2D 抓取当前视图区域到 GPU Texture `bg_texture`。
    2.  `PointerMove`: Shader 中 `out = Blend(bg_texture, brush_color)`。
    3.  `PointerUp`: 回读笔触（注意，如果带了背景，回读时要扣除背景，或者回读整个区域直接覆盖 Canvas 2D）。

### 优化建议 3: Shader 算法的“查表法”实现细节

文档提到“验证 erf 近似函数...如 CPU 用查表，GPU 也用查表”。这点非常重要，但 GPU 查表有纹理采样的开销和精度问题。

- **优化建议**：
  - **Uniform Buffer 传表**：不要用纹理（Texture Sampling 有线性插值误差），把 CPU 的查表数组（通常只有 256 或 1024 个 float）放入 `Uniform Buffer` 或 `Storage Buffer`。
  - **Shader 实现**：

    ```wgsl
    @group(0) @binding(3) var<storage, read> gaussian_table: array<f32>;

    fn get_gaussian(dist: f32) -> f32 {
        let index = u32(clamp(dist, 0.0, 1.0) * 1023.0);
        return gaussian_table[index]; // 保证与 CPU 查表完全一致的离散值
    }
    ```

### 优化建议 4: 预乘 Alpha (Premultiplied Alpha) 的数学陷阱

文档提到了修复“白色边缘线”。这是 GPU 渲染中最常见的 Bug。

- **补充检查清单**：
  - 在 Shader 输出最后，必须确保：`output.rgb <= output.a`。永远不要输出 `rgb=0.5, a=0.1` 这种值（在预乘模式下这是非法的，意味着发光物体）。
  - **强制修正代码**：
    ```wgsl
    // 防止非法预乘值
    out.rgb = min(out.rgb, vec3(out.a));
    ```
  - **混合公式确认**：
    标准预乘混合公式：`Target = Source + Dest * (1 - Source.a)`。确认你的 Fragment Shader 并没有错误地写成 `Target = Source * Source.a + ...`（因为输入已经是预乘的了，不要乘两次）。

---

### 总结优化后的执行路径

1.  **Phase 0 (测试)**: 必须包含 **“不同混合模式”** 的测试用例（不仅仅是 Normal 模式），这决定了架构是否需要支持 Grab Pass。
2.  **Phase 1 (Shader)**:
    - 优先对齐 Gamma/Linear 空间。
    - 使用 Storage Buffer 实现查表，放弃数学近似函数，追求 100% 像素匹配。
    - 添加 `out.rgb = min(out.rgb, vec3(out.a))` 守卫代码。
3.  **Phase 2 (架构)**:
    - 采用 **Overlay 方案**。
    - 为支持复杂混合模式，设计 **“背景回读机制 (Grab Pass)”**，仅在必要时启用（性能换正确性）。

如果按照这些优化点实施，这套方案不仅能解决性能问题，还能真正做到专业级的“像素级完美（Pixel Perfect）”。
