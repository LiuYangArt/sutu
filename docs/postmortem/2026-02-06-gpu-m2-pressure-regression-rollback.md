# GPU-First M2：压感回归与偶发丢笔触，阶段性回退复盘（2026-02-06）

**日期**：2026-02-06  
**状态**：已回退并验证压感恢复（保留 GPU 提交锁改动，撤销压感策略实验）

## 背景

在 M2 单层 GPU 可绘重构中，为解决“大画布起笔 1px 细线/偶发不出笔”，我们对 WinTab 压力采样与起笔策略做了一轮收紧：
- WinTab 优先取特定来源的起笔压力
- `pointerdown` 增加 `currentPoint` 新鲜度兜底
- 起笔回放增加策略性修正

该轮改动上线后，出现明显回归：
- 压感变得不顺滑，笔触宽度呈“珠串/扭曲”波动
- 手绘路径不稳定，但回放路径可正常出图

结论：问题由输入到画布落笔阶段引入，不是捕获/回放数据本身损坏。

## 现象与影响

1. 输入手感退化（高频）
- 压感曲线不连续，起笔/行笔过渡断层

2. 正确性信号混乱（中频）
- 门禁报告可 PASS，但手绘体感明显 FAIL

3. 验证成本上升（中频）
- 输入链路与渲染链路耦合后，单点改动难定位

影响判断：
- 在该基线上继续做性能优化会污染结论
- 必须先恢复稳定输入基线，再继续 M2 后续阶段

## 关键证据与经验

1. 手绘异常但回放正常  
这说明压感数据“进系统”大概率是正常的，问题更集中在 `pressure -> canvas stroke` 这段实时应用路径。

2. 初始表现为大画布更易复现，随后小画布也出现  
这说明“性能/时序”可能是放大器，但不是唯一根因。策略本身存在路径级风险，不能简单归因为大画布性能。

3. `startPressureFallbackCount` 可作为风险信号，但不能单独等价为质量结论  
必须和主观手绘结果、回放结果、诊断条件一起看。

## 本次处置

已回退压感实验改动，恢复到回归前的输入基线：
- `src/components/Canvas/inputUtils.ts`
- `src/components/Canvas/usePointerHandlers.ts`
- `src/components/Canvas/useStrokeProcessor.ts`
- `src/components/Canvas/__tests__/inputUtils.test.ts`（同步回到基线行为断言）

保留不回退项：
- `src/components/Canvas/useBrushRenderer.ts` 中已验证有效的 GPU commit finishing lock
- Debug Panel 的 Phase6A 门禁按钮流与诊断分代能力（用于后续稳定性验证）

回退后结果（用户实测）：
- 压感手感恢复到可用基线

## 决策

采用“稳定性优先”路线：
1. 保持当前压感基线，不再叠加新输入策略
2. 先完成 6A 稳定性门禁与非压感阻塞项
3. 压感问题作为独立专题，后续以分层实验再进入

不采用“在回归输入基线上继续压性能”的路线，避免返工。

## 后续行动（Gate）

进入下一阶段前，必须满足稳定性门禁：
1. `5000x5000` 单层连续绘制无丢笔触/消失
2. 无 `GPUValidationError` / device lost
3. 抬笔后无延迟补 dab
4. 压感起笔与行笔连续，无明显细线伪迹

通过后再执行性能项：
- 减少 CPU 参与链路
- 缩短 commit 路径耗时
- 回填 M2 验收与性能数据

## 临时豁免决议（选项 2）

在 2026-02-06 的协作决策中，选择“临时豁免”推进策略：
- 允许先做后续开发与性能探索，避免主线停滞。
- 不将当前状态记为 6A 通过，不输出封版级稳定性结论。
- 对外与对内文档统一标记为 `PARTIAL PASS`，并保留“最终前必须回归 6A 全量复验”的约束。

## 后续收敛补记（2026-02-06，工具切换与交互一致性）

在完成压感策略回退后，又暴露出一组“非压感、但影响稳定性体感”的交互问题：

1. `undo` 偶发一次撤销多笔，且“画几笔后第一次 undo”存在明显延迟。  
2. `brush/zoom/eyedropper` 快速切换时，上一笔笔触会闪烁。  
3. 未抬笔切到 `zoom` 并立即缩放，当前笔触有概率丢失。  
4. 吸色后切回画笔出现卡顿。

### 根因归类

1. **笔触状态机与工具状态耦合过深**  
   队列消费和收尾提交在部分路径依赖 `currentTool==='brush'`；工具切换发生在“笔触未完成”窗口时，尾点可能被当作陈旧数据丢弃。

2. **工具切换时缺少统一收笔栅栏**  
   从线条工具切到 `zoom/eyedropper` 时，未强制结束当前 stroke，导致缩放/吸色与提交流程竞争。

3. **显示面切换策略导致瞬态不一致**  
   GPU 可见面在工具切换时被过早关闭，出现“上一笔闪一下”的视觉抖动。

4. **吸色采样路径的 CPU 参与过重**  
   吸色依赖 CPU 侧合成读取，触发额外同步，放大了切工具后的首次交互卡顿。

### 修复策略（已落地）

1. 将笔触队列消费条件改为“只看 stroke 状态”，不再依赖当前工具类型。  
2. 在进入 `zoom`、以及从 `brush/eraser` 切出时，统一先 `finishCurrentStroke()`。  
3. 扩大 GPU 显示保持条件（`brush/zoom/eyedropper`），并增加工具切换过渡保护。  
4. 吸色优先走 GPU 单像素采样（失败再回退），降低 CPU 同步路径触发概率。  
5. 增加空闲期预同步，降低首次 `undo` 的突发延迟。

### 结果

- 用户最新回归反馈：`undo/zoom/吸色/工具切换` 当前均可用，闪烁与明显卡顿已消失。  
- 本轮自动验证通过：`typecheck` + 全量 `vitest`（`31 passed / 204 passed`）。  

### 经验沉淀

1. **工具态不是笔触态**：任何收尾、队列消费、提交逻辑必须以 stroke 生命周期为主键。  
2. **切工具先收笔**：从线条工具切到非线条工具必须有统一栅栏，不允许“半笔触”跨工具存活。  
3. **吸色优先采显示结果**：在不修改内容的工具上，优先读取 screen-space/GPU 输出，减少读回和同步链路干扰。  
4. **门禁要覆盖交互时序**：不仅要测“能画”，还要专门测“未抬笔切工具 + 立即操作”的竞态场景。
