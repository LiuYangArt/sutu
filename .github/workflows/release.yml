name: Release

on:
  push:
    tags:
      - 'v*'

env:
  CARGO_TERM_COLOR: always

permissions:
  contents: write
  issues: read

jobs:
  # ============================================
  # Fast preflight (fail early before full build)
  # ============================================
  preflight:
    name: Preflight checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Validate Cargo target dependency scopes
        shell: bash
        run: |
          set -euo pipefail

          cargo tree --manifest-path src-tauri/Cargo.toml --target aarch64-apple-darwin > mac-tree.txt

          if grep -E "wintab_lite v|libloading v" mac-tree.txt; then
            echo "Found Windows-only dependencies in macOS dependency tree."
            exit 1
          fi

          required=(base64 quick-xml image byteorder zip tiff dirs sha2 hex)
          missing=()

          for dep in "${required[@]}"; do
            if ! grep -q "${dep} v" mac-tree.txt; then
              missing+=("$dep")
            fi
          done

          if [ ${#missing[@]} -gt 0 ]; then
            echo "Missing common dependencies in macOS dependency tree: ${missing[*]}"
            exit 1
          fi

          echo "Cargo dependency scope preflight passed."

  # ============================================
  # Build per platform
  # ============================================
  build:
    name: Build ${{ matrix.platform_name }}
    needs: preflight
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            platform: windows
            platform_name: Windows
            bundle_targets: msi,nsis
          - os: macos-latest
            platform: macos
            platform_name: macOS
            bundle_targets: app,dmg
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get version from tag
        id: get_version
        shell: bash
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install frontend dependencies
        run: pnpm install --frozen-lockfile

      - name: Read app name
        id: app_meta
        shell: bash
        run: |
          app_name=$(node -e "const fs=require('fs'); const conf=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json','utf8')); process.stdout.write(conf.productName);")
          echo "app_name=$app_name" >> "$GITHUB_OUTPUT"

      - name: Resolve macOS signing identity
        if: matrix.platform == 'macos'
        id: mac_sign
        shell: bash
        env:
          APPLE_SIGNING_IDENTITY_SECRET: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          if [ -n "${APPLE_SIGNING_IDENTITY_SECRET}" ]; then
            echo "identity=${APPLE_SIGNING_IDENTITY_SECRET}" >> "$GITHUB_OUTPUT"
            echo "mode=developer-id" >> "$GITHUB_OUTPUT"
          else
            echo "identity=-" >> "$GITHUB_OUTPUT"
            echo "mode=adhoc" >> "$GITHUB_OUTPUT"
          fi

      - name: Print macOS signing mode
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          echo "Using macOS signing mode: ${{ steps.mac_sign.outputs.mode }}"

      - name: Build Tauri app
        env:
          APPLE_SIGNING_IDENTITY: ${{ matrix.platform == 'macos' && steps.mac_sign.outputs.identity || '' }}
          APPLE_CERTIFICATE: ${{ matrix.platform == 'macos' && secrets.APPLE_CERTIFICATE || '' }}
          APPLE_CERTIFICATE_PASSWORD: ${{ matrix.platform == 'macos' && secrets.APPLE_CERTIFICATE_PASSWORD || '' }}
          APPLE_ID: ${{ matrix.platform == 'macos' && secrets.APPLE_ID || '' }}
          APPLE_PASSWORD: ${{ matrix.platform == 'macos' && secrets.APPLE_PASSWORD || '' }}
          APPLE_TEAM_ID: ${{ matrix.platform == 'macos' && secrets.APPLE_TEAM_ID || '' }}
        run: pnpm tauri build --bundles ${{ matrix.bundle_targets }}

      - name: Verify macOS bundle signatures
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob

          apps=(src-tauri/target/release/bundle/macos/*.app)
          if [ ${#apps[@]} -eq 0 ]; then
            echo "No .app bundle found to verify." >&2
            exit 1
          fi

          for app in "${apps[@]}"; do
            echo "Verifying app bundle: ${app}"
            codesign --verify --deep --strict --verbose=2 "$app"
            signature_info="$(codesign -dv --verbose=4 "$app" 2>&1 || true)"
            if echo "$signature_info" | grep -q "Sealed Resources=none"; then
              echo "Invalid app signature (Sealed Resources=none): ${app}" >&2
              echo "$signature_info"
              exit 1
            fi
          done

          dmgs=(src-tauri/target/release/bundle/dmg/*.dmg)
          if [ ${#dmgs[@]} -eq 0 ]; then
            echo "No .dmg bundle found to verify." >&2
            exit 1
          fi

          for dmg in "${dmgs[@]}"; do
            echo "Verifying dmg payload app signature: ${dmg}"
            attach_output="$(hdiutil attach "$dmg" -nobrowse -readonly)"
            mount_point="$(echo "$attach_output" | awk '/\/Volumes\// {sub(/^.*Apple_HFS[[:space:]]+/, "", $0); print $0; exit}')"
            if [ -z "$mount_point" ] || [ ! -d "$mount_point" ]; then
              mount_point="$(echo "$attach_output" | awk '/\/Volumes\// {sub(/^.*\t/, "", $0); print $0; exit}')"
            fi
            if [ -z "$mount_point" ] || [ ! -d "$mount_point" ]; then
              echo "Failed to locate mounted dmg volume for ${dmg}" >&2
              echo "$attach_output"
              exit 1
            fi
            mounted_app="$(find "$mount_point" -maxdepth 1 -type d -name '*.app' | head -n1)"
            if [ -z "$mounted_app" ]; then
              echo "No .app found inside ${dmg}" >&2
              hdiutil detach "$mount_point" -quiet || true
              exit 1
            fi
            codesign --verify --deep --strict --verbose=2 "$mounted_app"
            hdiutil detach "$mount_point" -quiet
          done

      - name: Create Portable ZIP
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $appName = "${{ steps.app_meta.outputs.app_name }}"
          $exePath = "src-tauri/target/release/$appName.exe"
          if (-not (Test-Path $exePath)) {
            $fallbackExe = Get-ChildItem "src-tauri/target/release" -Filter "*.exe" -ErrorAction SilentlyContinue |
              Where-Object { $_.Name -notmatch "uninstall" } |
              Sort-Object LastWriteTime -Descending |
              Select-Object -First 1
            if (-not $fallbackExe) {
              throw "Could not locate release executable."
            }
            $exePath = $fallbackExe.FullName
          }
          $zipName = "${appName}_${version}_x64-portable.zip"
          $zipPath = "src-tauri/target/release/bundle/$zipName"

          # Create temp directory and copy exe
          $tempDir = "src-tauri/target/release/bundle/portable"
          New-Item -ItemType Directory -Force -Path $tempDir
          Copy-Item $exePath $tempDir

          # Create zip
          Compress-Archive -Path "$tempDir/*" -DestinationPath $zipPath -Force
          Write-Host "Created portable ZIP: $zipPath"

      - name: Collect Windows release assets
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          $dest = "release-assets/windows"
          New-Item -ItemType Directory -Force -Path $dest | Out-Null

          $patterns = @(
            "src-tauri/target/release/bundle/msi/*.msi",
            "src-tauri/target/release/bundle/nsis/*.exe",
            "src-tauri/target/release/bundle/*.zip"
          )

          foreach ($pattern in $patterns) {
            Get-ChildItem -Path $pattern -ErrorAction SilentlyContinue | ForEach-Object {
              Copy-Item $_.FullName -Destination $dest -Force
            }
          }

          $copied = Get-ChildItem -Path $dest -File -ErrorAction SilentlyContinue
          if (-not $copied) {
            throw "No Windows release assets were collected."
          }

          $copied | ForEach-Object {
            Write-Host "Collected Windows asset: $($_.Name)"
          }

      - name: Collect macOS release assets
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          mkdir -p release-assets/macos
          shopt -s nullglob
          files=(
            src-tauri/target/release/bundle/dmg/*.dmg
            src-tauri/target/release/bundle/macos/*.app.tar.gz
            src-tauri/target/release/bundle/macos/*.app.tar.gz.sig
          )

          app_dirs=(src-tauri/target/release/bundle/macos/*.app)
          if [ ${#app_dirs[@]} -gt 0 ]; then
            for app_dir in "${app_dirs[@]}"; do
              app_name="$(basename "$app_dir")"
              archive_name="${app_name}.tar.gz"
              tar -czf "release-assets/macos/${archive_name}" -C "$(dirname "$app_dir")" "$app_name"
              files+=("release-assets/macos/${archive_name}")
            done
          fi

          if [ ${#files[@]} -eq 0 ]; then
            echo "No macOS release assets were collected." >&2
            echo "Bundle directory snapshot:" >&2
            find src-tauri/target/release/bundle -maxdepth 3 -print || true
            exit 1
          fi

          for file in "${files[@]}"; do
            if [[ "$file" == release-assets/macos/* ]]; then
              continue
            fi
            cp "$file" release-assets/macos/
          done
          for file in "${files[@]}"; do
            echo "Collected macOS asset: $(basename "$file")"
          done

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-assets-${{ matrix.platform }}
          path: release-assets/${{ matrix.platform }}/*
          if-no-files-found: error
          retention-days: 7

  # ============================================
  # Publish release after all builds completed
  # ============================================
  publish-release:
    name: Publish GitHub Release
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read app name
        id: app_meta
        shell: bash
        run: |
          app_name=$(node -e "const fs=require('fs'); const conf=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json','utf8')); process.stdout.write(conf.productName);")
          echo "app_name=$app_name" >> "$GITHUB_OUTPUT"

      - name: Get version from tag
        id: get_version
        shell: bash
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: release-assets-*
          path: release-assets
          merge-multiple: true

      - name: List release assets
        shell: bash
        run: |
          find release-assets -type f | sort

      - name: Generate release body
        shell: bash
        env:
          APP_NAME: ${{ steps.app_meta.outputs.app_name }}
          RELEASE_TAG: ${{ github.ref_name }}
          RELEASE_VERSION: ${{ steps.get_version.outputs.VERSION }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{ github.token }}
          RELEASE_NOTES_API_KEY: ${{ secrets.RELEASE_NOTES_API_KEY || secrets.OPENAI_API_KEY }}
          RELEASE_NOTES_MODEL: ${{ vars.RELEASE_NOTES_MODEL || 'gpt-4.1-mini' }}
          RELEASE_NOTES_API_BASE_URL: ${{ vars.RELEASE_NOTES_API_BASE_URL || 'https://api.openai.com' }}
          RELEASE_NOTES_API_PATH: ${{ vars.RELEASE_NOTES_API_PATH || '/v1/chat/completions' }}
        run: node scripts/generate-release-notes.mjs

      - name: Upload Release Assets
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ steps.app_meta.outputs.app_name }} v${{ steps.get_version.outputs.VERSION }}
          draft: false
          prerelease: false
          body_path: release-body.md
          files: |
            release-assets/**/*
