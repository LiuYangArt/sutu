#!/usr/bin/env node

const SECTION_KEYS = ['p0', 'p1', 'p2', 'p3'];
const SECTION_TITLE_MAP = {
  p0: 'P0 Blockers',
  p1: 'P1 Important Bugs',
  p2: 'P2 Features',
  p3: 'P3 Backlog',
  duplicates: 'Recently Closed as Duplicate',
};

function normalizeInlineText(text) {
  return String(text || '')
    .replace(/\s+/g, ' ')
    .trim();
}

function toIsoTime(value) {
  const date = value ? new Date(value) : new Date();
  if (Number.isNaN(date.getTime())) {
    return new Date().toISOString();
  }
  return date.toISOString();
}

function formatIssueLine(item) {
  const labels = Array.isArray(item.labels) ? item.labels.filter(Boolean).join(', ') : '';
  const reason = normalizeInlineText(item.reason || 'Pending triage details.');
  const title = normalizeInlineText(item.title || '');
  return `- [ ] #${item.number} ${title} | labels: ${labels} | reason: ${reason} | [Issue](${item.url})`;
}

function formatDuplicateLine(item) {
  const title = normalizeInlineText(item.title || '');
  const canonicalPart = item.canonicalNumber ? ` | canonical: #${item.canonicalNumber}` : '';
  return `- #${item.number} ${title}${canonicalPart} | [Issue](${item.url})`;
}

function renderTodoMarkdown({
  generatedAt,
  repository = '',
  sections = {},
  duplicates = [],
  note = 'This file is auto-generated by issue triage workflow.',
}) {
  const lines = [
    '# Issue Todo List',
    '',
    `- Repository: ${repository || 'unknown'}`,
    `- Last Updated (UTC): ${toIsoTime(generatedAt)}`,
    `- Note: ${note}`,
    '',
  ];

  for (const sectionKey of SECTION_KEYS) {
    const title = SECTION_TITLE_MAP[sectionKey];
    lines.push(`## ${title}`);
    const items = Array.isArray(sections[sectionKey]) ? sections[sectionKey] : [];
    if (items.length === 0) {
      lines.push('- [ ] (empty)');
    } else {
      for (const item of items) {
        lines.push(formatIssueLine(item));
      }
    }
    lines.push('');
  }

  lines.push(`## ${SECTION_TITLE_MAP.duplicates}`);
  if (!Array.isArray(duplicates) || duplicates.length === 0) {
    lines.push('- (none)');
  } else {
    for (const item of duplicates) {
      lines.push(formatDuplicateLine(item));
    }
  }
  lines.push('');

  return lines.join('\n');
}

function parseSectionKeyByHeading(heading) {
  const normalized = normalizeInlineText(heading).toLowerCase();
  if (normalized === SECTION_TITLE_MAP.p0.toLowerCase()) return 'p0';
  if (normalized === SECTION_TITLE_MAP.p1.toLowerCase()) return 'p1';
  if (normalized === SECTION_TITLE_MAP.p2.toLowerCase()) return 'p2';
  if (normalized === SECTION_TITLE_MAP.p3.toLowerCase()) return 'p3';
  if (normalized === SECTION_TITLE_MAP.duplicates.toLowerCase()) return 'duplicates';
  return '';
}

function parseIssueLine(line) {
  const matched = line.match(
    /^- \[( |x)\] #(\d+)\s+(.+?)\s+\| labels: (.+?) \| reason: (.+?) \| \[Issue\]\((.+)\)\s*$/i,
  );
  if (!matched) {
    return null;
  }
  return {
    checked: matched[1].toLowerCase() === 'x',
    number: Number.parseInt(matched[2], 10),
    title: normalizeInlineText(matched[3]),
    labels: matched[4]
      .split(',')
      .map((item) => item.trim())
      .filter(Boolean),
    reason: normalizeInlineText(matched[5]),
    url: matched[6].trim(),
  };
}

function parseDuplicateLine(line) {
  const matched = line.match(/^- #(\d+)\s+(.+?)(?: \| canonical: #(\d+))? \| \[Issue\]\((.+)\)\s*$/i);
  if (!matched) {
    return null;
  }
  return {
    number: Number.parseInt(matched[1], 10),
    title: normalizeInlineText(matched[2]),
    canonicalNumber: matched[3] ? Number.parseInt(matched[3], 10) : null,
    url: matched[4].trim(),
  };
}

function parseTodoMarkdown(markdown) {
  const lines = String(markdown || '').split(/\r?\n/);
  const sections = { p0: [], p1: [], p2: [], p3: [] };
  const duplicates = [];
  let currentSection = '';

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) {
      continue;
    }
    const headingMatch = line.match(/^##\s+(.+)$/);
    if (headingMatch) {
      currentSection = parseSectionKeyByHeading(headingMatch[1]);
      continue;
    }

    if (currentSection === 'duplicates') {
      const duplicate = parseDuplicateLine(line);
      if (duplicate) {
        duplicates.push(duplicate);
      }
      continue;
    }

    if (SECTION_KEYS.includes(currentSection)) {
      const issue = parseIssueLine(line);
      if (issue) {
        sections[currentSection].push(issue);
      }
    }
  }

  return { sections, duplicates };
}

function flattenSections(sections) {
  const result = [];
  for (const key of SECTION_KEYS) {
    for (const item of sections[key] || []) {
      result.push({ ...item, section: key });
    }
  }
  return result;
}

export { flattenSections, parseTodoMarkdown, renderTodoMarkdown, SECTION_KEYS, SECTION_TITLE_MAP };
